"""Module contains functionality that parser main page for Microsoft vulnerabilities."""

import os.path
import time
import xlrd
from lxml import etree
from selenium import webdriver
from selenium.common.exceptions import NoSuchElementException, WebDriverException
from selenium.common.exceptions import TimeoutException
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.keys import Keys
from cve_connector.vendor_cve.implementation.parsers.general_and_format_parsers.html_parser \
    import HtmlParser
from cve_connector.vendor_cve.implementation.utilities.check_correctness import is_correct_cve_id
from cve_connector.vendor_cve.implementation.utilities.utility_functions import normalize_string


def get_string_date(date):
    """
    Returns date in a specified format.

    :param date: date of type date
    :return: date as a  string
    """
    return str(date.month) + '/' + str(date.day) + '/' + str(date.year)


def do_click(elem):
    """
    Simulates click.

    :param elem: element on which the click is accomplished
    :return: True if successful
    """
    try:
        elem.click()
        return True
    except WebDriverException:
        return False


class MicrosoftExcelMainPageParser(HtmlParser):
    """
    Class providing functionality for parsing Microsoft main page.
    """
    def __init__(self, url, directory, logger, from_date=None, to_date=None):
        super().__init__(url, from_date, to_date)
        self.date_format = '%m/%d/%Y'  # 04/10/2018
        self.driver = None
        self.cve_ids = set()
        self.file_location = directory
        self.profile = None
        try:
            self.load_content()
        except ValueError:
            logger.error('Unable to load content from {0}'.format(self.url))

    def get_content_from_ulr(self):
        """
        Gets and returns content from URL.

        :return: content
        """
        if not self.url:
            raise ValueError('Url must not be empty.')
        succ = False
        content = ''
        while not succ:
            succ, content = self.try_to_get_content()
        filter_set = False
        while not filter_set:
            filter_set = self.fill_date_boxes()
            self.reload_content()
        return content

    def try_to_get_content(self):
        """
        Gets content.

        :return: tuple: True, content
        """
        options = Options()
        options.add_experimental_option("prefs", {
            "download.default_directory": r"{}".format(self.file_location),
            "download.prompt_for_download": False
        })
        options.add_argument('--headless')
        options.add_argument('--no-sandbox')

        driver = webdriver.Chrome(chrome_options=options)

        driver.command_executor._commands["send_command"] = \
            ("POST", '/session/$sessionId/chromium/send_command')
        params = {'cmd': 'Page.setDownloadBehavior',
                  'params': {'behavior': 'allow', 'downloadPath': self.file_location}}
        driver.execute("send_command", params)

        driver.implicitly_wait(5)
        driver.get(self.url)
        content = driver.page_source
        self.driver = driver
        return True, content

    def proceed_to_update_guide(self, driver):
        """
        Proceeds to update guide.

        :param driver: web driver
        :return: True if successful
        """
        try:
            accept = driver.find_element_by_xpath('.//input[@type="button" and @value="Accept"]')
            if accept:
                click = False
                while not click:
                    accept = driver.find_element_by_xpath(
                        './/input[@type="button" and @value="Accept"]')
                    click = do_click(accept)

            return True
        except (TimeoutException, WebDriverException):
            return False

    def parse(self):
        """
        Provides parsing functionality.

        :return: None
        """
        downloaded = False
        while not downloaded:
            downloaded = self.download_excel()
        self.driver.close()
        cves_list = self.get_cves_from_excel()
        self.entities.extend(cves_list)

    def download_excel(self):
        """
        Downloads excel table.

        :return: True if only one file was downloaded
        """
        excel = self.driver.find_element_by_xpath(
            './/*[@id="objectObject"]/div/div/div/div/div[2]/div[1]/div/div/div/div/div[4]/button')

        do_click(excel)
        start_button = self.driver.find_element_by_xpath(
            '/html/body/div[2]/div/div/div/div[2]/div[3]/div[2]/div/div/button')

        if not os.path.exists(self.file_location):
            os.makedirs(self.file_location)
        else:
            files = os.listdir(self.file_location)
            for file in files:
                os.remove(os.path.join(self.file_location, file))

        do_click(start_button)
        start = time.time()
        while not os.listdir(self.file_location):
            time.sleep(2)
            end = time.time()
            if (end - start) >= 60:
                raise ValueError("Microsoft files were not downloaded in time.")
        return len(os.listdir(self.file_location)) == 1

    def reload_content(self):
        """
        Helper function for reloading content.

        :return: None
        """
        content = self.driver.page_source
        self.data = etree.HTML(content.replace('<br>', ''))

    def fill_date_boxes(self):
        """
        Fill data boxes on the web page of Microsoft.

        :return: True if successful
        """
        from_date_string = get_string_date(self.from_date)
        try:
            vulnerabilities = self.driver.find_element_by_name('Vulnerabilities')
            do_click(vulnerabilities)
            date_range = self.driver.find_element_by_xpath(
                './/button[@title="Select a different date range"]')
            do_click(date_range)
            click_elem = self.driver.find_element_by_xpath(
                '/html/body/div[2]/div/div/div/div/div/div[2]/ul/li[1]/div/div/div[1]/div')
            do_click(click_elem)
            option_elem = self.driver.find_element_by_xpath(
                '/html/body/div[3]/div/div/div/div/div/div/button[3]')
            do_click(option_elem)

            from_textbox = self.driver.find_element_by_xpath(
                '/html/body/div[2]/div/div/div/div/div/div[2]/ul/li[1]/div/div/div[2]/div/div/div/div/input')
            from_textbox.clear()
            from_textbox.send_keys(10*Keys.BACK_SPACE)
            from_textbox.send_keys(from_date_string, Keys.ENTER)

            click_elem2 = self.driver.find_element_by_xpath(
                '/html/body/div[2]/div/div/div/div/div/div[2]/ul/li[2]/div/div/div[1]/div')
            do_click(click_elem2)
            option_elem2 = self.driver.find_element_by_xpath(
                '/html/body/div[3]/div/div/div/div/div/div/button[4]')
            do_click(option_elem2)
            ok_button = self.driver.find_element_by_xpath(
                '/html/body/div[2]/div/div/div/div/div/div[2]/ul/li[5]/div/div/button[1]')
            do_click(ok_button)

            return True
        except NoSuchElementException:
            return False

    def get_cves_from_excel(self):
        """
        Extract CVEs from the downloaded Excel table.

        :return: set of CVEs
        """
        files = os.listdir(self.file_location)
        cves = []
        for file in files:
            workbook = xlrd.open_workbook(os.path.join(self.file_location, file))
            sheet = workbook.sheet_by_index(0)
            col_index = self.find_index_of_cve_column(sheet)
            if col_index < 0:
                raise ValueError('Fomat of provided xlsx sheet has changed.')
            vals = self.get_values_of_given_col(sheet, col_index)
            cves.extend(vals)
        return set(cves)

    def get_values_of_given_col(self, sheet, col_index):
        """
        Extract CVEs from the given column.

        :param sheet: excel sheet
        :param col_index: index of column in excel table
        :return: CVEs
        """
        cves = set()
        for i in range(1, sheet.nrows):
            data = normalize_string(sheet.cell_value(i, col_index))
            if data == '':
                break
            if is_correct_cve_id(data):
                cves.add(data)
        return cves

    def find_index_of_cve_column(self, sheet):
        """
        Find index where CVEs are placed in the excel table.

        :param sheet: sheet of excel table
        :return: index or -1
        """
        row_index = 0
        for i in range(0, 4):
            if 'CVE Number' in sheet.cell_value(row_index, i):
                return i
        return -1
