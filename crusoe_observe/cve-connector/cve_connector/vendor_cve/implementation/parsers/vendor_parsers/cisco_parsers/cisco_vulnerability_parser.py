"""Module contains functionality for parsing HTML page of a particular vulnerability."""

import re
import urllib.request
from lxml import etree
from cve_connector.vendor_cve.implementation.parsers.general_and_format_parsers\
    .html_parser import HtmlParser
from cve_connector.vendor_cve.implementation.parsers.vendor_parsers.cisco_parsers\
    .cisco_cvrf import CiscoXmlParser
from cve_connector.vendor_cve.implementation.vendors_storage_structures.cisco import Cisco
from cve_connector.vendor_cve.implementation.vulnerability_metrics.cvss_v3_metrics import CvssV3
from cve_connector.vendor_cve.implementation.utilities.check_correctness \
    import is_correct_cve_id, is_correct_cwe, is_correct_score, \
    is_correct_vector_v3
from cve_connector.vendor_cve.implementation.utilities.utility_functions \
    import normalize_string, concat_strings, get_current_date, \
    string_to_date, get_number_from_string


class CiscoVulnerabilityParser(HtmlParser):
    """
    Contains functionality for parsing HTML of specific CVE.
    """
    def __init__(self, url, logger, from_date=None, to_date=None):
        super().__init__(url, from_date, to_date)
        self.date_format = '%Y %B %d'  # 2018 January 4

        self.load_content()

        self.cve_details_dict = {}
        self.parsed_cve_ids = []
        self.parsed_summary = ''
        self.parsed_advisory_id = ''
        self.parsed_cwes = []
        self.parsed_cvss_base = ''
        self.parsed_cvss_temporal = ''
        self.parsed_attack_vector = ''
        self.parsed_severity = ''
        self.parsed_analysis = ''
        self.parsed_date = get_current_date()
        self.patched = False
        self.logger = logger

    def get_content_from_ulr(self):
        """
        Gets and returns content from URL.

        :return: content
        """
        response = urllib.request.urlopen(self.url)
        if response.getcode() != 200:
            self.logger.info("Cisco - get_content_from_url()")
            raise ConnectionError('Unable to load ', self.url)
        content = response.read()
        response.close()
        return content

    def parse(self):
        """
        Provides parsing functionality.

        :return: None
        """
        content_list = self.data.xpath(
            './/div[@id="advisorycontentcontainer"]//div[@class="mainContent"]')
        if not content_list:
            return False
        content = content_list[0]
        advisory_header_list = content.xpath('.//div[@id="advisorycontentheader"]')
        if not advisory_header_list:
            return False

        advisory_header = advisory_header_list[0]
        self.parse_header_items(advisory_header)

        link_to_xml_content = self.get_xml_link(advisory_header)
        correct_parsed_xml = False

        if link_to_xml_content != '':
            correct_parsed_xml = self.parse_xml(link_to_xml_content)

        if link_to_xml_content == '' or not correct_parsed_xml:
            advisory_content_body = content.xpath('.//div[@id="advisorycontentbody"]')[0]
            self.parse_header_items(advisory_header)
            self.parsed_summary = self.parse_summary(advisory_content_body)
            self.parse_analysis(advisory_content_body)
            self.check_patched(advisory_content_body)
            if len(self.parsed_cve_ids) == 1:
                i = self.parsed_cve_ids[0]
                self.cve_details_dict[i] = self.parse_details_one_cve(content)
            else:
                details_dict = self.parse_details_more_cves(content)
                self.complete_cve_dictionary(details_dict)

        if correct_parsed_xml:
            self.complete_xml_parsing()

        self.complete_entities()

    def complete_xml_parsing(self):
        """
        Assigns values to each particular property.

        :return: None
        """
        for item in self.entities:
            item.severity = self.parsed_severity
            item.cwes.extend(self.parsed_cwes)
            item.advisory_id = self.parsed_advisory_id
            item.attack_vector = self.parsed_attack_vector
            if self.parsed_cvss_base != '' and is_correct_score(self.parsed_cvss_base):
                cvss_v3 = CvssV3(base_sc=self.parsed_cvss_base)
                if self.parsed_cvss_temporal != '' \
                        and is_correct_score(self.parsed_cvss_temporal):
                    cvss_v3.temporal_sc = self.parsed_cvss_temporal
                item.cvss_v3 = cvss_v3
            item.cvss_base_sc_v3 = self.parsed_cvss_base
            item.cvss_temporal_score_v3 = self.parsed_cvss_temporal
            item.published = self.parsed_date

    def complete_entities(self):
        """
        Creates list of Cisco vulnerabilities as a property.

        :return: None
        """
        for item in self.cve_details_dict:
            cisco = Cisco(cve=item)
            cisco.details = self.cve_details_dict[item]
            cisco.summary = self.parsed_summary
            cisco.advisory_id = self.parsed_advisory_id
            cisco.attack_vector = self.parsed_attack_vector
            cisco.cvss_temporal_score_v3 = self.parsed_cvss_temporal
            cisco.cvss_base_sc_v3 = self.parsed_cvss_base
            if self.parsed_cvss_base != '' and is_correct_score(self.parsed_cvss_base):
                cvss_v3 = CvssV3(base_sc=self.parsed_cvss_base)
                if self.parsed_cvss_temporal != '' and is_correct_score(self.parsed_cvss_temporal):
                    cvss_v3.temporal_sc = self.parsed_cvss_temporal
                cisco.cvss_v3 = cvss_v3
            cisco.severity = self.parsed_severity
            cisco.analysis = self.parsed_analysis
            cisco.description = self.parsed_summary + ' ' \
                + self.parsed_analysis + ' ' + self.cve_details_dict[item]
            cisco.published = self.parsed_date
            cisco.patch_available = self.patched

            for cwe in self.parsed_cwes:
                if is_correct_cwe(cwe):
                    cisco.cwes.append(cwe)
            if cisco.is_valid_entity():
                self.entities.append(cisco)

    def complete_cve_dictionary(self, dct):
        """
        Sets complete dictionary of parsed CVEs as a property.

        :param dct: properties of CVEs to be set (dictionary)
        :return: None
        """
        for cve in self.parsed_cve_ids:
            dict_value = ''
            if cve in dct:
                dict_value = dct[cve]
            self.cve_details_dict[cve] = dict_value

    def get_xml_link(self, content):
        """
        Extract from the content link for XML file.

        :param content: downloaded content
        :return: XML link or empty string
        """
        xml_link_list = content.xpath('.//a[contains(text(), "Download CVRF")]/@href')
        return xml_link_list[0] if xml_link_list else ''

    def parse_xml(self, link):
        """
        Parses XML downloaded from link.

        :param link: download link
        :return: True if successful
        """
        parser = CiscoXmlParser(link)
        try:
            parser.load_content()
        except ConnectionError as conn_err:
            self.logger.error('Cisco Parser - Error: ', str(conn_err))
            return False
        except etree.ParseError as parse_err:
            self.logger.error('Cisco Parser - Error: ', str(parse_err))
            return False
        parser.parse()
        entities = parser.entities
        self.entities.extend(entities)
        self.patched = True
        return True

    def parse_details_one_cve(self, content):
        """
        Parse properties of particular CVE.

        :param content: downloaded content
        :return: string containing details of CVE
        """
        details_list = content.xpath('.//div[@id="detailfield"]/span//text()')
        return concat_strings(details_list, ' ')

    def parse_details_more_cves(self, content):
        """
        Extracts and returns CVEs from the content.

        :param content: downloaded content
        :return: string containing details
        """
        result = {}
        detail = ''
        header_appeared = False
        vuln_headers = content.xpath('.//*[self::strong or self::h3]/text()')
        details_list = content.xpath('.//div[@id="detailfield"]/span//text()')
        for item in details_list:
            item = normalize_string(item)
            if item == '':
                continue
            if item in vuln_headers:
                header_appeared = True
                detail = ''
            elif header_appeared:
                cve_match = self.cve_match(item)
                if cve_match == '':
                    detail += item
                else:
                    result[cve_match] = detail
                    detail = ''
        return result

    def cve_match(self, string):
        """
        Extracts CVE ID from the string.

        :param string: raw string that might contain CVE ID
        :return: cve or empty string
        """
        pattern_list = [r'assigned the following CVE ID: (CVE-\d+-\d+)',
                        r'ID for this vulnerability is: (CVE-\d+-\d+)']

        for pattern in pattern_list:
            match = re.search('{0}'.format(pattern), string)
            if match:
                cve = match.group(1)
                if is_correct_cve_id(cve):
                    return cve
        return ''

    def parse_analysis(self, content):
        """
        Extracts and returns analysis from the content.

        :param content: downloaded content
        :return: analysis
        """
        analysis_list = content.xpath('.//div[@id="analysisfield"]//text()')
        analysis = ''
        for text in analysis_list:
            analysis += normalize_string(text)
        return str(analysis)

    def parse_summary(self, content):
        """
        Extracts and returns summary from the content.

        :param content: downloaded content
        :return: summary
        """
        summary_list = content.xpath('.//div[@id="summaryfield"]//text()')
        summary = ''
        for text in summary_list:
            summary += normalize_string(text)
        return summary

    def parse_severity(self, content):
        """
        Extracts and returns severity from the content.

        :param content: downloaded content
        :return: severity
        """
        severity_list = content.xpath('.//div[@id="severitycirclecontent"]/text()')
        if len(severity_list) != 1:
            raise ValueError("Wrong parsed severity")
        return str(severity_list[0])

    def parse_header_items(self, header):
        """
        Parses header item from downloaded tables.

        :param header: header of table
        :return: None
        """
        self.parsed_severity = self.parse_severity(header)

        self.parsed_date = self.get_published_date(header)

        advisory_id_list = header.xpath('.//div[@id="ud-advisory-identifier"]'
                                        '/div[@class="divLabelContent"]/text()')
        if len(advisory_id_list) != 1:
            raise ValueError("Wrong parsed advisory id")
        self.parsed_advisory_id = str(advisory_id_list[0])

        cve_list = header.xpath(
            './/div[@class="cve-cwe-containerlarge"]//div[@class="CVEList"]/div/text()')
        self.parsed_cve_ids.extend(i for i in cve_list if is_correct_cve_id(i))

        cwe_list = header.xpath(
            './/div[@class="cve-cwe-containerlarge"]//div[@class="CWEList"]//text()')
        self.parsed_cwes.extend(c for c in cwe_list if is_correct_cwe(c))

        score_list = header.xpath('.//div[contains(@class, "ud-CVSSScore")]//input/@value')
        if score_list:
            base = re.search(r'Base (\d{1,2}\.\d)', score_list[0])
            if base:
                base_sc = get_number_from_string(base.group(1))
                self.parsed_cvss_base = base_sc

            temporal = re.search(r'Temporal (\d.\d)', score_list[0])
            if temporal:
                temp_sc = get_number_from_string(temporal.group(1))
                self.parsed_cvss_temporal = temp_sc

            cvss_vector = re.search(
                r'CVSS:3\.0/AV:\S+/AC:\S+/PR:\S+/UI:\S+/S:\S+/C:\S+/I:\S+/A:\S+/E:\S+/RL:\S+'
                r'/RC:\S+', score_list[0])
            if cvss_vector and is_correct_vector_v3(cvss_vector.group(0)):
                self.parsed_attack_vector = str(cvss_vector.group(0))

    def get_published_date(self, content):
        """
        Extracts and returns published date from the content.

        :param content: downloaded content
        :return: date
        """
        date_list = content.xpath(
            './/div[@id="ud-published"]//div[@class="divLabelContent"]/text()')
        if not date_list:
            return get_current_date()
        date_string_list = re.findall(r'\d{4}\xa0\w+\xa0\d+', str(date_list[0]))
        if not date_string_list:
            return get_current_date()
        date_string = date_string_list[0].replace('\xa0', ' ')
        date = string_to_date(date_string, self.date_format)
        return date

    def check_patched(self, content):
        """
        Sets property patched according to the tested information.

        :param content: downloaded content
        :return: None
        """
        vendor_ann_text = concat_strings(content.xpath(
            './/div[@id="vendorannouncefield"]//text()'))
        fixed_sw_text = concat_strings(content.xpath('.//div[@id="fixedsoftfield"]//text()'))
        if 'has released' in vendor_ann_text:
            self.patched = True
            return
        if 'has released' not in fixed_sw_text or 'not released'in fixed_sw_text:
            self.patched = False
        else:
            self.patched = True
