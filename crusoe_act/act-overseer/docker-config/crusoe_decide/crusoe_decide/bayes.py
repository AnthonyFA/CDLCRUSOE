"""
Module bayes.py contains functionality which creates Bayesian Attack Graph
and infers final probabilities.
"""

import re
import os
from pgmpy.models import BayesianModel
from pgmpy.factors.discrete import TabularCPD
from pgmpy.inference import VariableElimination


def convert_attack_graph_to_bayesian(arcs_file, vertices_file, client, logger):
    """
    This function converts attack graph generated by MULVAL to a Bayesian (attack) graph
    and returns final probability for tuple (C, I, A) - confidentiality, integrity and availability.

    :param arcs_file: path to a file with edges of attack graph generated by MULVAL
    :param vertices_file: path to a file with nodes of attack graph generated by MULVAL
    :param client: neo4j client
    :param logger: logger for logging progress of algorithm and time information
    :return: a tuple containing probabilities for confidentiality, integrity and availability,
    i.e. (C, I, A).
    """
    incidence_list = {}
    conf_goal = None
    integ_goal = None
    avail_goal = None

    # if file does not exist, MULVAL did not find any attack path
    if not os.path.exists(arcs_file):
        return 0.0, 0.0, 0.0

    with open(arcs_file, "r") as txtfile:
        for line in txtfile:
            result = re.match(r'(?P<end>[0-9]+),(?P<start>[0-9]+),-1', line)
            if result['start'] in incidence_list:
                incidence_list[result['start']].append(result['end'])
            else:
                incidence_list[result['start']] = []
                incidence_list[result['start']].append(result['end'])

    nodes_dict = {}
    with open(vertices_file, "r") as txtfile:
        for line in txtfile:
            result = re.match(
                r'(?P<id>\d+),"(?P<description>.+)","(?P<relation>[A-Z]+)",(?P<coef>[0-9\.]+)',
                line)
            nodes_dict[result['id']] = {'description': result['description'],
                                        'relation': result['relation']}
            # we assume that there won't be both of the goal types together
            if "sysConfLoss" in result['description'] or "appConfLoss" in result['description']:
                conf_goal = result['id']
                continue

            if "sysIntegLoss" in result['description'] or "appIntegLoss" in result['description']:
                integ_goal = result['id']
                continue

            if "sysAvailLoss" in result['description'] or "appAvailLoss" in result['description']:
                avail_goal = result['id']
                continue

    attack_graph_model = create_bayesian_model(client, incidence_list, nodes_dict, logger=logger)

    return infer_final_probability(attack_graph_model, conf_goal, integ_goal,
                                   avail_goal, logger=logger)


def infer_final_probability(bayesian_model, conf_goal, integ_goal, avail_goal, logger):
    """
    Function infers final probability for the triple (C, I, A) - confidentiality, integrity
    and availability.

    :param bayesian_model: bayesian model (graph) with all nodes, edges and CPDs already added
    :param conf_goal: confidentiality goal - node in a graph which is an attack goal
    :param integ_goal: integrity goal
    :param avail_goal: availability goal
    :param logger: logger for logging progress of algorithm and time information
    :return: a tuple containing probabilities for confidentiality, integrity and availability,
    i.e. (C, I, A)
    """
    logger.info("Probability inference started.")
    infer = VariableElimination(bayesian_model)
    if conf_goal is not None:
        conf_prob = infer.query([conf_goal])[conf_goal].values[1]
    else:
        conf_prob = 0.0
    if integ_goal is not None:
        integ_prob = infer.query([integ_goal])[integ_goal].values[1]
    else:
        integ_prob = 0.0
    if avail_goal is not None:
        avail_prob = infer.query([avail_goal])[avail_goal].values[1]
    else:
        avail_prob = 0.0
    logger.info("Probability inference ended.")
    return conf_prob, integ_prob, avail_prob


def create_bayesian_model(client, incidence_list, nodes_dict, logger):
    """
    Function creates bayesian model (graph) with all nodes, edges and CPDs.

    :param client: neo4j client
    :param incidence_list: incidence list for the graph
    :param nodes_dict: dictionary containing for each node its description
    and relation (AND / OR / LEAF).
    :param logger: logger for logging progress of algorithm and time information
    :return: created Bayesian model
    """
    attack_graph_model = BayesianModel()

    for edge_start in incidence_list:
        for edge_end in incidence_list[edge_start]:
            attack_graph_model.add_edge(edge_start, edge_end)

    for node_id in nodes_dict:
        # There  are three  types of  nodes  in MulVAL  i.e.: LEAF  node for
        # configuration node, OR node for privilege node, and AND node for attack step
        if nodes_dict[node_id]['relation'] == 'LEAF':
            if 'vulExists' in nodes_dict[node_id]['description']:
                cve_id = re.match(
                    r"vulExists\([a-zA-Z_0-9]+,[ ]?'(?P<cve_id>CVE-[0-9]{4}-[0-9]{4,7})',.*",
                    nodes_dict[node_id]['description']).groupdict()['cve_id']
                exploitability = client.get_exploitability(cve_id)
                cpd = TabularCPD(variable=node_id, variable_card=2, values=[[1-exploitability],
                                                                            [exploitability]])
                attack_graph_model.add_cpds(cpd)
            else:
                cpd = TabularCPD(variable=node_id, variable_card=2, values=[[0.0], [1.0]])
                attack_graph_model.add_cpds(cpd)
        else:
            predecessors = set()
            for edge_start in incidence_list:
                for edge_end in incidence_list[edge_start]:
                    if edge_end == node_id:
                        predecessors.add(edge_start)
            if nodes_dict[node_id]['relation'] == 'AND':
                cpd = TabularCPD(variable=node_id, variable_card=2,
                                 values=[[1.0]*(2**len(predecessors)-1) + [0.2],
                                         [0.0]*(2**len(predecessors)-1) + [0.8]],
                                 evidence=list(predecessors),
                                 evidence_card=[2]*len(predecessors))
                attack_graph_model.add_cpds(cpd)
            elif nodes_dict[node_id]['relation'] == 'OR':
                cpd = TabularCPD(variable=node_id, variable_card=2,
                                 values=[[1] + [0]*(2**len(predecessors)-1),
                                         [0] + [1]*(2**len(predecessors)-1)],
                                 evidence=list(predecessors),
                                 evidence_card=[2]*len(predecessors))
                attack_graph_model.add_cpds(cpd)
    logger.info("Bayesian model was created successfully.")
    return attack_graph_model
