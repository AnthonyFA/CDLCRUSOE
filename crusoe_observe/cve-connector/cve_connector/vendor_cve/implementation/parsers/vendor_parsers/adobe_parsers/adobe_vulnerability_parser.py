"""Module contains functionality for parsing particular CVE (vendor Adobe)."""

import re
import urllib.request

from cve_connector.vendor_cve.implementation.parsers.general_and_format_parsers\
    .html_parser import HtmlParser
from cve_connector.vendor_cve.implementation.parsers.vendor_parsers.adobe_parsers\
    .adobe_vulnerability_details import AdobeVulnerabilityDetails
from cve_connector.vendor_cve.implementation.vendors_storage_structures.adobe import Adobe

from cve_connector.vendor_cve.implementation.utilities.utility_functions \
    import concat_strings, normalize_string, string_to_date


def normalize_versions(versions):
    """
    Modifies input string to a form which will be further processed.

    :param versions: input string
    :return: modified string
    """
    return re.sub(r'[ ]{2,}', '', versions).replace('\n', ',').strip()


class AdobeVulnerabilityParser(HtmlParser):
    """
    Class for parsing HTML page associated to particular vulnerability.
    """
    def __init__(self, url):
        super().__init__(url)
        self.date_format = '%B %d, %Y'  # April 10, 2017
        self.load_content()
        self.vulnerability_details = []
        self.published = ''
        self.priority = ''
        self.parsed_summary = ''

    def get_content_from_ulr(self):
        """
        Gets appropriate content from URL.

        :return: content
        """
        response = urllib.request.urlopen(self.url)
        if response.getcode() != 200:
            raise ConnectionError('Unable to load ', self.url)
        content = response.read()
        response.close()
        return content

    def parse(self):
        """
        Provides parsing functionality.

        :return: None
        """
        vuln_details_table = self.data.xpath('.//table[tbody//tr[1]//*[contains(text(), "CVE")]]')
        if not vuln_details_table:
            return
        for table in vuln_details_table:
            header_items, data = self.parse_table(table)
            self.set_vuln_details(header_items, data)

        summary_list = self.data.xpath(
            './/div[preceding-sibling::div[div//*[contains(text(), "Summary")]]][1]'
            '/div[@class="text"]//*/text()')
        if summary_list:
            self.parsed_summary = concat_strings(summary_list)

        bulletin_info_table_list = \
            self.data.xpath('.//table[tbody/tr//*[contains(text(), "Bulletin")]]')
        if len(bulletin_info_table_list) != 1:
            raise ValueError("Invalid Bulletin info table.")
        bulletin_table = bulletin_info_table_list[0]
        bulletin_header, bulletin_items = self.parse_table(bulletin_table)
        if len(bulletin_items) != 1:
            raise ValueError("Invalid Bulletin info table.")
        for header_item, data_item in zip(bulletin_header, bulletin_items[0]):
            self.set_bulletin_item(header_item, data_item)

        self.add_entities()

    def add_entities(self):
        """
        Creates list of Adobe vulnerabilities as a property of class.

        :return: None
        """
        for entry in self.vulnerability_details:
            for cve_id in entry.cve_ids:
                new_entity = Adobe()
                new_entity.cve_id = cve_id
                new_entity.severity = entry.severity
                new_entity.vuln_category = entry.vulnerability_category
                new_entity.impact = entry.vulnerability_impact
                new_entity.summary = self.parsed_summary
                new_entity.description = self.parsed_summary
                new_entity.priority = self.priority
                new_entity.published = self.published
                if new_entity.is_valid_entity():
                    self.entities.append(new_entity)

    def set_bulletin_item(self, header_item, data_item):
        """
        For each key in header_dictionary which is also in header_item calls
        function (value in header_dictionary) on data_item.

        :param header_item: header of table parsed in parse() method
        :param data_item: one row of table parsed in parse() method
        :return: None
        """
        header_dictionary = {
            'date': self.set_date_published,
            'priority': self.set_priority
        }

        for header in header_dictionary:
            if header in header_item.lower():
                header_dictionary.get(header)(data_item)
                break

    def set_date_published(self, attr):
        """
        Set property for date when the vulnerability was first published.

        :param attr: raw string containing the date
        :return: None
        """
        date = string_to_date(normalize_string(attr), self.date_format)
        self.published = date

    def set_priority(self, attr):
        """
        Set property priority.

        :param attr: raw string containing priority
        :return: None
        """
        self.priority = normalize_string(attr)

    def set_vuln_details(self, header, data):
        """
        Set property - list of adobe vulnerability details.

        :param header: header of table
        :param data: rows of table
        :return: None
        """
        for row in data:
            new_vuln_details = AdobeVulnerabilityDetails()
            for header_item, data_item in zip(header, row):
                self.set_vuln_details_item(header_item, normalize_string(data_item),
                                           new_vuln_details)
            self.vulnerability_details.append(new_vuln_details)

    def set_vuln_details_item(self, header_item, data_item, entity):
        """
        Set one item containing adobe vulnerability details.

        :param header_item: header from table
        :param data_item: row from table
        :param entity: entity whose properties are to be set
        :return: None
        """
        header_dictionary = {
            'category': self.set_vuln_cat,
            'impact': self.set_vuln_impact,
            'severity': self.set_severity,
            'cve': self.set_cve,
            'version': self.set_aff_version
        }

        for header in header_dictionary:
            if header in header_item.lower():
                header_dictionary.get(header)(data_item, entity)
                break

    @staticmethod
    def set_vuln_cat(attr, entity):
        """
        Set property vulnerability category.

        :param attr: raw string containing vulnerability category
        :param entity: entity whose property is set
        :return:
        """
        entity.vulnerability_category = normalize_string(attr)

    @staticmethod
    def set_vuln_impact(attr, entity):
        """
        Set property vulnerability impact.

        :param attr: raw string containing vulnerability impact
        :param entity: entity whose vulnerability impact is to be set
        :return: None
        """
        entity.vulnerability_impact = normalize_string(attr)

    @staticmethod
    def set_severity(attr, entity):
        """
        Set property severity.

        :param attr: raw string containing severity
        :param entity: entity whose severity is to be set
        :return: None
        """
        entity.severity = normalize_string(attr)

    @staticmethod
    def set_cve(attr, entity):
        """
        Set cve property.

        :param attr: raw string containing CVE ID
        :param entity: entity whose CVE is set
        :return: None
        """
        cve_pattern = r'CVE-\d{4}-\d+'
        cves = re.findall(cve_pattern, attr)
        entity.cve_ids.extend(normalize_string(cve) for cve in cves)

    @staticmethod
    def set_aff_version(attr, entity):
        """
        Set affected version.

        :param attr: raw string containing affected version
        :param entity: entity whose property is set
        :return: None
        """
        entity.affected_version = attr
