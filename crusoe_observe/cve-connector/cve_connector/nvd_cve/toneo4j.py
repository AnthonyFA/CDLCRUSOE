"""
Module contains functionality that creates from parsed CVE data
appropriated nodes in the database.
"""

from datetime import datetime
import os
import re
import structlog
from neo4jclient.CveConnectorClient import CVEConnectorClient
from cve_connector.nvd_cve.categorization import classifier
from cve_connector.nvd_cve import utility
from cve_connector.nvd_cve import cve_parser


def move_cve_data_to_neo4j(specified_time, neo4j_passwd, directory, logger=structlog.get_logger()):
    """
    Create CVE nodes in graph identified by CVE_ID with properties according to CVE.

    :param specified_time: CVEs which has modification date after this date are created
    or just updated - in isoformat
    :param neo4j_passwd: password to neo4j DB
    :param directory: path to directory where the downloaded CVE data will be stored
    :param logger: logger for the method
    :return output message
    """
    logger.info("Parameters passed to move_cve_data_to_neo4j() are "
                "specifed_time: {}, directory: {}."
                .format(specified_time, directory))

    client = CVEConnectorClient(password=neo4j_passwd)

    try:
        utility.download_necessary_files(directory)
    except ConnectionError as conn_err:
        logger.error(conn_err)
        return str(conn_err)

    # The lowest possible value is year 2002 - this might take very long time!
    # i = 2002

    cve_count_created = 0
    cve_count_updated = 0

    i = 2017
    while i <= datetime.now().year:
        created_delta, updated_delta = fill_data(
            client, os.path.join(directory, f'nvdcve-1.1-{i}.json'), specified_time)
        cve_count_created += created_delta
        cve_count_updated += updated_delta

        i += 1
    utility.delete_necessary_files(directory)

    output_string = "{0} CVEs were created, {1} CVEs were updated, " \
                    "{0} nodes of type Vulnerability were created" \
                    .format(cve_count_created, cve_count_updated)

    logger.info(output_string)
    return output_string


def fill_data(client, filename, specified_time, logger=structlog.get_logger()):
    """
    This function fills Neo4j database with the data in dictionary containing items
    of class Vulnerability in cve_parser.py.

    :param client: neo4j client
    :param filename: name of file to be parsed
    :param specified_time: CVEs which has modification date after this date are created
    or just updated - in isoformat
    :param logger: logger for the method
    :return: count of created and updated CVEs
    """
    logger.info("Parsing file {}.".format(filename))
    dict_of_vulnerability = cve_parser.parse(filename, specified_time)

    cve_count_created = 0
    cve_count_updated = 0

    for key in dict_of_vulnerability:
        if dict_of_vulnerability[key].cvssv2 and dict_of_vulnerability[key].cvssv3:
            # node is created only in a case when it does not exist
            vul_description = "Assumed vulnerability with ID " + key

            if not client.cve_exists(key):
                vulnerability_created = check_configurations(
                    client, dict_of_vulnerability[key].cpe_configurations,
                    vul_description, False, logger
                )

                if vulnerability_created:
                    client.create_cve_from_nvd(
                        CVE_id=key,
                        description=dict_of_vulnerability[key].description,
                        access_vector=dict_of_vulnerability[key].cvssv2['av'],
                        access_complexity=dict_of_vulnerability[key].cvssv2['ac'],
                        authentication=dict_of_vulnerability[key].cvssv2['au'],
                        confidentiality_impact_v2=dict_of_vulnerability[key].cvssv2['c'],
                        integrity_impact_v2=dict_of_vulnerability[key].cvssv2['i'],
                        availability_impact_v2=dict_of_vulnerability[key].cvssv2['a'],
                        base_score_v2=dict_of_vulnerability[key].cvssv2['score'],
                        obtain_all_privilege=dict_of_vulnerability[key]
                        .cvssv2['obtainAllPrivilege'],
                        obtain_user_privilege=dict_of_vulnerability[key]
                        .cvssv2['obtainUserPrivilege'],
                        obtain_other_privilege=dict_of_vulnerability[key]
                        .cvssv2['obtainOtherPrivilege'],
                        attack_vector=dict_of_vulnerability[key].cvssv3['av'],
                        attack_complexity=dict_of_vulnerability[key].cvssv3['ac'],
                        privileges_required=dict_of_vulnerability[key].cvssv3['pr'],
                        user_interaction=dict_of_vulnerability[key].cvssv3['ui'],
                        scope=dict_of_vulnerability[key].cvssv3['s'],
                        confidentiality_impact_v3=dict_of_vulnerability[key].cvssv3['c'],
                        integrity_impact_v3=dict_of_vulnerability[key].cvssv3['i'],
                        availability_impact_v3=dict_of_vulnerability[key].cvssv3['a'],
                        base_score_v3=dict_of_vulnerability[key].cvssv3['score'],
                        impact=classifier.classifier(dict_of_vulnerability[key]),
                        published_date=dict_of_vulnerability[key].published_date
                    )

                    client.create_relationship_between_cve_and_vulnerability(key, vul_description)
                    cve_count_created += 1
                    logger.info("{} was created.".format(key))
            else:
                # Control again versions, since some versions in our database might have been added
                check_configurations(client, dict_of_vulnerability[key].cpe_configurations,
                                     vul_description, True, logger)

                client.update_cve_from_nvd(
                    CVE_id=key,
                    description=dict_of_vulnerability[key].description,
                    access_vector=dict_of_vulnerability[key].cvssv2['av'],
                    access_complexity=dict_of_vulnerability[key].cvssv2['ac'],
                    authentication=dict_of_vulnerability[key].cvssv2['au'],
                    confidentiality_impact_v2=dict_of_vulnerability[key].cvssv2['c'],
                    integrity_impact_v2=dict_of_vulnerability[key].cvssv2['i'],
                    availability_impact_v2=dict_of_vulnerability[key].cvssv2['a'],
                    base_score_v2=dict_of_vulnerability[key].cvssv2['score'],
                    obtain_all_privilege=dict_of_vulnerability[key]
                    .cvssv2['obtainAllPrivilege'],
                    obtain_user_privilege=dict_of_vulnerability[key]
                    .cvssv2['obtainUserPrivilege'],
                    obtain_other_privilege=dict_of_vulnerability[key]
                    .cvssv2['obtainOtherPrivilege'],
                    attack_vector=dict_of_vulnerability[key].cvssv3['av'],
                    attack_complexity=dict_of_vulnerability[key].cvssv3['ac'],
                    privileges_required=dict_of_vulnerability[key].cvssv3['pr'],
                    user_interaction=dict_of_vulnerability[key].cvssv3['ui'],
                    scope=dict_of_vulnerability[key].cvssv3['s'],
                    confidentiality_impact_v3=dict_of_vulnerability[key].cvssv3['c'],
                    integrity_impact_v3=dict_of_vulnerability[key].cvssv3['i'],
                    availability_impact_v3=dict_of_vulnerability[key].cvssv3['a'],
                    base_score_v3=dict_of_vulnerability[key].cvssv3['score'],
                    impact=classifier.classifier(dict_of_vulnerability[key]),
                    published_date=dict_of_vulnerability[key].published_date
                )
                cve_count_updated += 1
                logger.info("{} was updated.".format(key))
    return cve_count_created, cve_count_updated


def parse_cpe(full_cpe):
    """
    This function extracts vendor, product and version from CPE in the full form
    cpe:2.3:[aoh]:*{10} = string 'cpe:2.3' is followed by a/o/h and ten groups.

    :param full_cpe: CPE match string in its full form
    :return: vendor, product, and version
    """
    if '\\:' in full_cpe:
        cpe_parts = full_cpe.split(":")
        vendor = cpe_parts[3]
        while vendor.endswith('\\') and len(cpe_parts) > 13:
            vendor += ":" + cpe_parts[4]
            cpe_parts.pop(4)
        product = cpe_parts[4]
        while product.endswith('\\') and len(cpe_parts) > 13:
            product += ":" + cpe_parts[5]
            cpe_parts.pop(5)
        version = cpe_parts[5]
        while product.endswith('\\') and len(cpe_parts) > 13:
            version += ":" + cpe_parts[6]
            cpe_parts.pop(6)
    else:
        cpe_parts = full_cpe.split(':')
        vendor = cpe_parts[3]
        product = cpe_parts[4]
        version = cpe_parts[5]
    return vendor, product, version


def check_ranges(cpe_item, version):
    """
    According to the specification, CPE uses also ranges with the keywords
    'version[Start|End][Including|Excluding]'. This way it specifies ranges of versions
    which are affected by the CVE, for example versions from 4.0.0 to 4.5.0.

    :param cpe_item: cpe data
    :param version: version to be checked
    :return: True if the version is in the specified range
    """
    if "versionStartIncluding" in cpe_item and \
            version < cpe_item['versionStartIncluding']:
        return False
    if "versionStartExcluding" in cpe_item and \
            version <= cpe_item['versionStartExcluding']:
        return False
    if "versionEndIncluding" in cpe_item and \
            version > cpe_item["versionEndIncluding"]:
        return False
    if "versionEndExcluding" in cpe_item and \
            version >= cpe_item["versionEndExcluding"]:
        return False
    return True


def check_configurations(client, cpe_configurations, vul_description, flag, logger):
    """
    This function checks for each possible configuration, whether some software version
    from the DB is affected and creates relationship with the vulnerability.

    :param client: neo4j client
    :param cpe_configurations: configurations of software versions
    :param vul_description: description of vulnerability
    :param flag: determines whether vulnerability was already created
    :param logger: logger
    :return: True if vulnerability was created
    """
    vulnerability_created = flag
    for configuration in cpe_configurations:
        if configuration['operator'] == 'OR':
            if 'cpe_match' in configuration:
                for cpe_item in configuration['cpe_match']:
                    if cpe_item['vulnerable']:
                        vulnerability_created = process_nvd_cpe(client, cpe_item, vul_description,
                                                                vulnerability_created)
            else:
                logger.warn(f"This OR configuration does not contain key "
                            f"'cpe_match': {configuration}")
        elif configuration['operator'] == 'AND':
            if 'children' not in configuration:
                if 'cpe_match' not in configuration:
                    logger.warn(f"This configuration does not contain 'children' nor "
                                f"'cpe_match' key: {configuration}")
                    continue
                for cpe_item in configuration['cpe_match']:
                    if cpe_item['vulnerable']:
                        vulnerability_created = process_nvd_cpe(client, cpe_item, vul_description,
                                                                vulnerability_created)
            elif len(configuration['children']) == 2:
                if configuration['children'][0]['cpe_match'][0]['vulnerable']:  # is True
                    vulnerable_dict = configuration['children'][0]
                    non_vulnerable_dict = configuration['children'][1]
                else:
                    vulnerable_dict = configuration['children'][1]
                    non_vulnerable_dict = configuration['children'][0]

                if vulnerable_dict['operator'] != 'OR' or non_vulnerable_dict['operator'] != 'OR':
                    raise ValueError("Depth of recursion was more than 1.")

                for cpe_item in vulnerable_dict['cpe_match']:
                    if cpe_item['vulnerable']:
                        vulnerability_created = process_nvd_cpe(client, cpe_item, vul_description,
                                                                vulnerability_created)

            else:
                logger.warn(f"Not two children in AND configuration {configuration}")

    return vulnerability_created


def process_nvd_cpe(client, cpe_item, vul_description, flag):
    """
    Test all of the possibilities in which the CPE might appear in the DB and create
    vulnerability according to it.

    :param client: neo4j client
    :param cpe_item: cpe data
    :param vul_description: description of vulnerability
    :param flag: determines whether vulnerability was already created
    :return: True if vulnerability was created
    """
    vulnerability_created = flag
    vendor, product, version = parse_cpe(cpe_item['cpe23Uri'])

    # Testing only major and minor version without build
    if version.count('.') > 1:
        match = re.match(r"(?P<major>.*?)\.(?P<minor>.*?)\.(?P<build>.*)", version)
        shortened_cpe = vendor + ":" + product + ":" + match.group(1) + "." + match.group(2)
        if client.software_version_exists(shortened_cpe):
            if not vulnerability_created:
                vulnerability_created = True
                client.create_new_vulnerability(vul_description)
            client.create_relationship_between_vulnerability_and_software_version(
                vul_description, shortened_cpe
            )

    for possible_software_version in [vendor + ":" + product + ":" + version,
                                      vendor + ":" + product + ":*",
                                      vendor + ":*:*"]:
        if client.software_version_exists(possible_software_version):
            if not vulnerability_created:
                vulnerability_created = True
                client.create_new_vulnerability(vul_description)
            client.create_relationship_between_vulnerability_and_software_version(
                vul_description, possible_software_version)

    vendor_and_product = vendor + ":" + product + ":*"
    for sw_version in client.get_versions_of_product(vendor_and_product):
        possible_version = sw_version[sw_version.rfind(':') + 1:]
        if check_ranges(cpe_item, possible_version):
            if not vulnerability_created:
                vulnerability_created = True
                client.create_new_vulnerability(vul_description)
            client.create_relationship_between_vulnerability_and_software_version(
                vul_description, vendor + ":" + product + ":" + possible_version)
    return vulnerability_created
